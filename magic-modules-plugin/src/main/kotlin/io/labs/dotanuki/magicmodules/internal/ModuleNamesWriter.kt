package io.labs.dotanuki.magicmodules.internal

import com.squareup.kotlinpoet.ClassName
import com.squareup.kotlinpoet.FileSpec
import com.squareup.kotlinpoet.KModifier
import com.squareup.kotlinpoet.ParameterizedTypeName.Companion.parameterizedBy
import com.squareup.kotlinpoet.PropertySpec
import com.squareup.kotlinpoet.TypeSpec
import io.labs.dotanuki.magicmodules.internal.model.CanonicalModuleName
import io.labs.dotanuki.magicmodules.internal.model.GradleModuleInclude
import java.io.File

internal object ModuleNamesWriter {

    fun write(folder: File, filename: String, coordinates: Map<CanonicalModuleName, GradleModuleInclude>) {

        when {
            folder.isFile -> throw MagicModulesError.CantWriteConstantsFile
            coordinates.isEmpty() -> throw MagicModulesError.CantAcceptModulesNames
            else -> generateAndWriteKotlinCode(filename, coordinates, folder)
        }
    }

    private fun generateAndWriteKotlinCode(
        filename: String,
        coordinates: Map<CanonicalModuleName, GradleModuleInclude>,
        target: File
    ) {
        val objectWithConstantsSpec = TypeSpec.objectBuilder(filename)
            .apply { coordinates.asConstantsPropertiesSpec().forEach { addProperty(it) } }
            .addProperty(coordinates.keys.asListPropertySpec())
            .build()

        val fileSpec = FileSpec.builder(ROOT_PACKAGE, filename)
            .addComment(DO_NOT_EDIT)
            .addType(objectWithConstantsSpec)
            .indent(FOUR_SPACES)
            .build()

        fileSpec.writeTo(target)
    }

    private fun Set<CanonicalModuleName>.asListPropertySpec(): PropertySpec =
        ClassName("kotlin.collections", "List")
            .parameterizedBy(ClassName("kotlin", "String"))
            .let { parametrizedStringList ->

                val lineByLine = joinToString(
                    separator = LINE_BY_LINE_SEPARATOR,
                    prefix = LINE_BY_LINE_PREFIX,
                    postfix = LINE_BY_LINE_POSTFIX
                ) { name ->
                    name.value.enclosedWithQuotes()
                }

                val formatted = "\n${ALL_NAMES_TEMPLATE.replace("<items>", lineByLine).trimIndent()}"

                PropertySpec.builder("allAvailable", parametrizedStringList)
                    .initializer(formatted)
                    .build()
            }

    private fun String.enclosedWithQuotes() = "\"$this\""

    private fun Map<CanonicalModuleName, GradleModuleInclude>.asConstantsPropertiesSpec(): List<PropertySpec> =
        map { (name, include) ->
            PropertySpec.builder(name.value, String::class, KModifier.CONST)
                .initializer("%S", include.value)
                .build()
        }

    private const val FOUR_SPACES = "    "
    private const val LINE_BY_LINE_SEPARATOR = ",\n$FOUR_SPACES"
    private const val LINE_BY_LINE_PREFIX = "\n$FOUR_SPACES"
    private const val LINE_BY_LINE_POSTFIX = "\n"
    private const val ROOT_PACKAGE = ""
    private const val ALL_NAMES_TEMPLATE = "listOf(<items>)"
    private const val DO_NOT_EDIT = "Generated by MagicModules plugin. Please do not edit"
}