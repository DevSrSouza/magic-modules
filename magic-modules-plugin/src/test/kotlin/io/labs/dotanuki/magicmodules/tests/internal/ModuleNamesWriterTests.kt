package io.labs.dotanuki.magicmodules.tests.internal

import io.labs.dotanuki.magicmodules.internal.MagicModulesError
import io.labs.dotanuki.magicmodules.internal.ModuleNamesWriter
import io.labs.dotanuki.magicmodules.internal.model.CanonicalModuleName
import io.labs.dotanuki.magicmodules.internal.model.GradleModuleInclude
import io.labs.dotanuki.magicmodules.internal.model.GradleModuleType
import org.assertj.core.api.Assertions.assertThat
import org.assertj.core.api.Assertions.assertThatCode
import org.assertj.core.api.Assertions.assertThatThrownBy
import org.junit.Rule
import org.junit.Test
import org.junit.rules.TemporaryFolder

internal class ModuleNamesWriterTests {

    @get:Rule val tempFolder = TemporaryFolder()

    @Test fun `should not write on non-directory file`() {
        val target = tempFolder.newFile()

        val coordinates = mapOf(
            GradleModuleInclude(":library") to listOf(CanonicalModuleName("LIBRARY")),
            GradleModuleInclude(":app") to listOf(CanonicalModuleName("APP"))
        )

        val moduleType = GradleModuleType.LIBRARY

        val execution = { ModuleNamesWriter.write(target, moduleType, coordinates) }

        val expected = MagicModulesError.CantWriteConstantsFile
        assertThatThrownBy(execution).isEqualTo(expected)
    }

    @Test fun `should not write other modules when no names are provided`() {
        val target = tempFolder.newFolder()
        val coordinates = emptyMap<GradleModuleInclude, List<CanonicalModuleName>>()

        val moduleType = GradleModuleType.LIBRARY

        val execution = { ModuleNamesWriter.write(target, moduleType, coordinates) }

        val expected = MagicModulesError.CantAcceptModulesNames
        assertThatThrownBy(execution).isEqualTo(expected)
    }

    @Test fun `should not write java modules when no names are provided`() {
        val target = tempFolder.newFolder()
        val coordinates = emptyMap<GradleModuleInclude, List<CanonicalModuleName>>()

        val moduleType = GradleModuleType.JAVA_LIBRARY

        val execution = { ModuleNamesWriter.write(target, moduleType, coordinates) }

        assertThatCode(execution).doesNotThrowAnyException()
    }

    @Test fun `should write names as constants and also each name inside a list`() {
        val target = tempFolder.newFolder()

        val coordinates = mapOf(
            GradleModuleInclude(":core") to listOf(CanonicalModuleName("CORE")),
            GradleModuleInclude(":common") to listOf(CanonicalModuleName("COMMON"))
        )

        val moduleType = GradleModuleType.LIBRARY

        ModuleNamesWriter.write(target, moduleType, coordinates)

        val writtenCode = target.resolve("${moduleType.conventionFileName()}.kt").readText()
        val expectedCode = """
            // Generated by MagicModules plugin. Mind your Linters!
            import kotlin.String
            import kotlin.collections.List
            
            object ${moduleType.conventionFileName()} {
                const val CORE: String = ":core"

                const val COMMON: String = ":common"

                val allAvailable: List<String> = 
                        listOf(
                            CORE,
                            COMMON
                        )
            }
            
            """.trimIndent()

        assertThat(writtenCode).isEqualTo(expectedCode)
    }
}